:toc: macro
:toclevels: 2
:toc-title: Table of Contents

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :point_right:
:important-caption: :loudspeaker:
:caution-caption: :rotating_light:
:warning-caption: :warning:
endif::[]

= Spring Cheat Sheet

toc::[]

== Thread Management
Enable virtual threads for Tomcat.
[source,yaml]
----
spring:
  threads:
    virtual:
      enabled: true
----

== Persistence And JPA

=== Local Docker Setup for PostgreSQL
* Basis for a docker-compose.yaml:
+
[source,yaml]
----
services:
  products-db:
    image: postgres:16.3
    container_name: foo-db
    restart: always
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: foo
    volumes:
      - foo-db:/var/lib/postgresql/data
    ports:
      - 5432:5432
    command: ["postgres", "-c", "log_statement=all"]

  test-service-adminer:
    container_name: test-service-adminer
    image: adminer
    restart: always
    ports:
      - 9090:8080

volumes:
  foo-db:
----

=== General Setup
* Global setup:
+
[source,yaml]
----
spring:
  jpa:
    database: postgresql
    database-platform: org.hibernate.dialect.PostgreSQLDialect
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
    open-in-view: true
    hibernate:
      ddl-auto: none
----

* Profile specific configuration:
+
[source,yaml]
----
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/ecommerce
    username: user
    password: password
  liquibase:
    change-log: classpath:/db/changelog/db.changelog-master.yaml
  web:
    resources:
      add-mappings: true
----

=== Liquibase Setup

==== Changeset Definition

* Root Changeset:
+
[source,yaml]
----
databaseChangeLog:
  - includeAll:
      path: classpath:/db/changelog/changes/
      errorIfMissingOrEmpty: true
----

* Referenced changeset files (order is selected by filename descending):
+
[source,sql]
----
--liquibase formatted sql

--changeset author:1
CREATE TABLE IF NOT EXISTS price
(
    product_id INTEGER   NOT NULL,
    valid_from TIMESTAMP NOT NULL,
    valid_to   TIMESTAMP NOT NULL,
    currency   VARCHAR(255),
    value      FLOAT,
    PRIMARY KEY (product_id, valid_from, valid_to)
);
--rollback DROP TABLE price;
----

==== Spring Boot Centric Integration
* Required Dependency
** Only Spring Boot Integration (Version maintained by Spring Boot BOM):
+
[source,xml]
----
<dependency>
    <groupId>org.liquibase</groupId>
    <artifactId>liquibase-core</artifactId>
</dependency>
----

* Reference to the Changelog:
+
[source,yaml]
----
spring:
  liquibase:
    change-log: classpath:/db/changelog/db.changelog-master.yaml
----

==== Additional Setup For Maven Plugin
#TODO


=== Logging and Debugging

==== Additions to the Docker file/Docker compose file

* Enable statement logging:
+
[source,yaml]
----
    command: ["postgres", "-c", "log_statement=all"]
----

==== Application Properties Changes

[source,yaml]
----
spring:
  jpa:
    show-sql: true
    properties:
      hibernate:
        generate_statistics: true
logging:
  level:
    org.hibernate.SQL: WARN
    org.hibernate.type.descriptor.sql: TRACE
----

=== JPA Auditing and Versioning

==== Auditing
. Creating an AuditorAware Provider (_nota bene:_ Modify fetching of current principal to current need and security configuration)
+
[source,java]
----
@Slf4j
public class AuditorAwareProvider implements AuditorAware<String> {
    @Override
    public Optional<String> getCurrentAuditor() {

        var principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        if(principal instanceof User user) {
            return Optional.of(user.getUsername());
        }
        return Optional.empty();
    }
}
----

. Enabling auditing via configuration and exposing the bean implementing the SPI
+
[source,java]
----
@Configuration
@Slf4j
@EnableJpaAuditing(auditorAwareRef = "auditorAware")
public class AuditingConfiguration {
    @Bean
    public AuditorAware<String> auditorAware(){
        return new AuditorAwareProvider();
    }
}
----

. Setting up auditing on `Entity` level
+
[source,java]
----
@Table(name = "price")
@Getter
@Setter
@NoArgsConstructor
@Entity
@EntityListeners(AuditingEntityListener.class) // enable auditing for the entity
public class Price {

  @Id
  @Column(name = "product_id")
  private Integer productId;

  //...

  @CreatedDate
  @Column(name="created_at")
  private LocalDateTime createdAt;

  @CreatedBy
  @Column(name="created_by")
  private String createdBy;

  @LastModifiedDate
  @Column(name = "updated_at")
  private LocalDateTime updatedAt;

  @LastModifiedBy
  @Column(name = "updated_by")
  private String updatedBy;
}
----

==== Versioning via Envers

. Add Dependency
[source,xml]
+
----
<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-envers</artifactId>
    <version>${envers.version}</version>
</dependency>
----

. Add suitable versioning tables for audited entities

. Add `@Audited` Annotation to Entity Classes or Attributes
+
Don't forget to annotate non primitive associations as well if required.

== Consuming REST APIs

=== Using Spring 3 HTTP Interfaces with WebClient (Feign-Alike)
. Add a dependency to Spring Reactive Web
+
Required as this approach is based on the Reactive Stack.
+
[source,xml]
+
----
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>
----

. Create an Interface annotated with `@HttpExchange defining available endpoints
+
[source,java]
----
@HttpExchange(accept = APPLICATION_JSON_VALUE, contentType = APPLICATION_JSON_VALUE)
public interface FooClient {

    @PostExchange
    FooResponse doAComplicatedRequest(@RequestBody FooRequest request);

}
----

. Provide a `HttpClient` Bean
+
[source,java]
----
    @Bean
    HttpClient httpClient() {
        return HttpClient.create()
                .responseTimeout(properties.timeout());
    }
----

. Provide a `HttpServiceProxyFactory` Bean based on the HTTPClient
+
[source,java]
----
    @Bean
    HttpServiceProxyFactory httpServiceProxyFactory(HttpClient client){
        var webclient = WebClient.builder()
                .clientConnector(new ReactorClientHttpConnector(client))
                .baseUrl(properties.baseUrl())
                .defaultHeader(API_AUTHORIZATION_KEY, API_AUTHORIZATION_KEY)
                .defaultStatusHandler(HttpStatusCode::isError,
                        error -> error.bodyToMono(ErrorRecord.class)
                                .flatMap(body -> Mono.error(new ErrorRecord(body.error().message()))))
                .build();

        return HttpServiceProxyFactory.builder(WebClientAdapter.forClient(webclient))
                .blockTimeout(properties.timeout())
                .build();
----

. Use the `HttpServiceProxyFactory` Bean to create the client based on the Interface provided
+
[source,java]
----
    @Bean
    public FooClient fooClient(HttpServiceProxyFactory httpServiceProxyFactory) {
        return httpServiceProxyFactory.createClient(FooClient.class);
    }
----

==== Error Handling
Since WebClient is based on Spring's Reactive Stack, error handling needs some adaptions as well.

#TODO

[source,java]
----
    @Bean
    HttpServiceProxyFactory httpServiceProxyFactory(HttpClient client){
        var webclient = WebClient.builder()
                ...
                .defaultStatusHandler(HttpStatusCode::isError,
                        error -> error.bodyToMono(ErrorRecord.class)
                                .flatMap(body -> Mono.error(new ErrorRecord(body.error().message()))))
                ...
                .build();
----


==== Additional Resources
* https://www.baeldung.com/spring-6-http-interface[Baeldung HTTP Interface Tutorial]

=== Using Spring 3 HTTP Interfaces with RestClient (Feign-Alike)
. Alike Spring 3 HTTP Interfaces using the WebClient, create an Interface annotated with `@HttpExchange defining available endpoints
+
[source,java]
----
@HttpExchange(accept = APPLICATION_JSON_VALUE, contentType = APPLICATION_JSON_VALUE)
public interface FooClient {

    @PostExchange
    FooResponse doAComplicatedRequest(@RequestBody FooRequest request);

}
----

. Provide a `RESTClient` Bean
+
[source,java]
----
@Bean
RestClient RestClient() {
    return RestClient.create("https://www.foo-base-url/api/v1");
}
----

. Use the `RestClient` to create a Client
+
[source,java]
----
@Bean
RestClient RestClient(RestClient restClient) {
    HttpServiceProxyFactory factory = HttpServiceProxyFactory
            .builderFor(RestClientAdapter.create(client))
            .build();
    return factory.createClient(FooClient.class);
}
----

==== Additional Resources
* https://www.youtube.com/watch?v=UDNrJAvKc0k[DanVega Rest Client Tutorial]

== JSON Handling

=== Navigating JSON Objects via `JsonNode`

=== Creating Custom Deserializer

=== Testing JSON Handling Functionality
Annotate JSON related tests as
[source,java]
----
@JsonTest
public class FooDeserializerTest{
    //...
}
----

=== Additional Resources

== Other Stuff

=== "Load Testing" Local Applications

Via Apache Bench (`ab`):
[source,bash]
----
ab -c 20 //<1>
   -n 10 //<2>
  localhost:8080/foo/bar //<3>
----
<1> number of concurrent threads (will compete with threads of your application of course if run locally)
<2> number of requests
<3> URL

==== Additional Resources

* https://httpd.apache.org/docs/2.4/programs/ab.html[Documentation]